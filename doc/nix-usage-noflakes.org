#+title: Nix Setup and Usage without Flakes
#+setupfile: internal/links.org

* Org-mode setup :noexport:

This document is written in a project-agnostic way so it can be copied to other
projects that use Nix.

** Variables

We set variables in =internal/params.el= and access those settings with the
following macros and source code blocks (using Noweb).

#+name: get
#+begin_src emacs-lisp :var arg="" :eval yes :results silent
(alist-get (intern arg) (car (read-from-string (f-read "internal/params.el"))))
#+end_src

#+macro: get (eval (concat $2 (alist-get (intern $1) (car (read-from-string (f-read "internal/params.el")))) $3))
#+macro: package-attr-short {{{get(package-attr,=,=)}}}
#+macro: package-attr-long {{{get(package-attr,=packages.x86_64-linux.,=)}}}
#+macro: package-type {{{get(package-type)}}}
#+macro: package-target {{{get(package-target,=,=)}}}
#+macro: run-attr {{{get(run-attr,=,=)}}}
#+macro: run-target {{{get(run-target,=,=)}}}
#+macro: nix-release {{{get(nix-release)}}}
#+macro: nixos-release {{{get(nixos-release)}}}
#+macro: nixos-branch {{{get(nixos-release,=nixos-,=)}}}

** Formatting help

This snippet can be used as a post-processing step to crop down the results from
an evaluation of a source code block.

#+name: crop
#+begin_src emacs-lisp :var text="" :var first-n=5 :var last-n=5 :results silent
(let* ((ls         (split-string text "\n"))
       (first-ls   (-take first-n ls))
       (rest-first (-drop first-n ls))
       (rest-last  (-drop-last (+ 1 last-n) rest-first))
       (last-ls    (-take-last (+ 1 last-n) rest-first)))
  (string-join
   (if rest-last
       (append first-ls '("…") last-ls)
     (append first-ls last-ls))
   "\n"))
#+end_src

** Setup action

The following helps (using Noweb) set up Nix environment variables for source
block evaluation.

#+name: nix-init
#+begin_src sh :eval no
export NIX_PROFILE=$(pwd)/nix-profile
export NIX_PAGER=cat
export PATH="$NIX_PROFILE/bin:$PATH"
alias nix="nix --experimental-features nix-command"
#+end_src

Next we perform some side-effects to set up the evaluation of the whole
document.

#+name: cleanup
#+begin_src sh :dir .. :results output silent :noweb yes
<<nix-init>>
rm --force result*
rm --force "$NIX_PROFILE"*
#+end_src

This is just a hack to deal with the fact that we never know what directory a
session will start in, so we need a way to calculate the PWD to jump to it.

#+name: pwd-parent
#+begin_src sh :results output silent
echo cd "$(pwd)/.."
#+end_src

This begins a session with environment variables initialized.

#+name: session-init
#+begin_src sh :session env :results output silent :noweb yes
<<pwd-parent()>>
<<nix-init>>
#+end_src

* About this document

This document caters to users more interested in stability than new features.

For people new to [[nix][the Nix package manager]], this document gives a walk-through of
using Nix in the context of this project, but without turning on Nix's
still-experimental /flakes/ feature. A supplemental document covers [[file:nix-motivation.org][what Nix is
and the motivation to use it]]. This document also discusses the benefits and
liabilities of using flakes. We get better performance, reliability, and
ergonomics, but at the expense of coupling to an API that may change
dramatically.

Beyond flakes, the =nix= command released in 2018 is technically also still an
experimental feature. As of Nix 2.4, experimental features need to be enabled
explicitly. However, so many people were using =nix=, that by default it is
enabled. If you set the =experimental-features= option explicitly in your
=nix.conf= file, you need to include =nix-command=. But if you don't have a
setting for =experimental-features= then =nix-command= will be enabled for you.
When =nix-command= is disabled, the only subcommand you can call is =nix repl=.
When enabled, you get a lot more subcommands, short of the ones that require
other experimental features enabled such as =flakes=.

Note, the =nix= command has not been stable, true to its experimental status.
Notably, the API changed in Nix 2.4 considerably. If you're okay using the =nix=
command at all, you might as well be using a current version of it. Documenting
the 2.3 =nix= API is a losing proposition. It will pretty soon be deprecated
completely in favor on something newer.

This document will also show a few commands you can run irrespective of which
version of Nix you have installed, without a requirement of any experimental
features. Here's some commands we'll cover which you can run with no such
requirements:
- =nix-build=
- =nix-collect-garbage=
- =nix repl=

We'll also cover a few commands that should work if you're on Nix 2.4 or higher
and have the =nix-command= experimental feature enabled. Hopefully, the usage of
these commands as illustrated is stable enough. You can recognize these commands
easily because they will be =nix= subcommands beyond =nix repl=.

Note, some users may be using [[nixos][NixOS]], a Linux operating system built on top of
Nix. Those users already have Nix and don't need to install it separately. To
use this project, you don't need to use NixOS as well. Nix can be installed on a
variety of Linux and Mac systems. Nix can also be installed in Windows via the
Windows Subsystem for Linux (WSL). Installation on WSL may involve steps not
covered in this documentation, though.

#+include: "nix-usage-flakes.org::*How this project uses Nix"

#+include: "nix-usage-flakes.org::*Level of commitment/risk"

* Installation and setup

#+include: "nix-usage-flakes.org::*Nix package manager installation"

#+include: "nix-usage-flakes.org::*Cache setup"

** Optionally Upgrade Nix

#+begin_quote
*_NOTE:_* This section likely only applies to NixOS users
#+end_quote

If you installed Nix as per the instructions above, you should have a recent
version of Nix:

#+name: nix-version
#+begin_src sh :results output :exports both
nix --version
#+end_src

#+RESULTS: nix-version
: nix (Nix) 2.4

However, if you're using the latest NixOS release of {{{nixos-release}}}, you
are probably still on Nix 2.3. Upgrading to 2.4 or later can be done by editing
your system's =configuration.nix= as follows:

#+begin_src nix :eval no
{ pkgs, ... }: {

    # ... the rest of your configuration

    # Upgrade Nix to get flakes
    nix.package = pkgs.nixFlakes;

    # Enable `nix` command in the newer version of Nix
    nix.extraOptions = ''
        experimental-features = nix-command
    '';

}
#+end_src

Even though we're using the version of Nix recent enough to support flakes
(=pkgs.nixFlakes= above), you have to explicitly turn on flakes to use them,
which we aren't doing.

* Working with Nix

Though covering Nix comprehensively is beyond the scope of this document, we'll
go over a few commands illustrating some usage of Nix with this project.

** Nix files

As mentioned Nix expressions are written in the Nix expression language and
saved in files with a ~.nix~ extension. Nix files can be collocated with the
source they package, but this isn't necessary or always the case.

Various Nix commands will accept filepaths to these Nix files as arguments. If a
filepath is a directory, a file named ~default.nix~ is referenced within.

** Inspecting this project for packages

This project has a =default.nix= file at it's root. This is a Nix expression
that allows users to access this project's flake outputs without having flakes
enabled on their machines. Using the =default.nix= file (instead of the
project's flake file) comes at the cost of some extra time evaluating the
expression.

The Nix expressions of projects generally evaluate to a /attribute/ trees of
packages. We can select out these packages by traversing an /attribute path/.
These attribute paths are dot-delimited.

The non-experimental way of exploring what's in a Nix expression is to load it
into a [[repl][REPL]] session and to tab-complete through the various attributes of the
tree:

#+begin_src sh :eval no
nix repl .
#+end_src

=nix repl= expects filepaths to Nix files as positional arguments. If these
files contain attribute sets, the attributes are bound to variables within the
REPL session.

If you opted to enable the =nix-command= experimental feature for a Nix version
2.4 or greater, you can use the =nix search= command to search the provided
=default.nix= file:

#+begin_src sh :eval no
nix search --file . ''
#+end_src

#+name: nix-search-local
#+begin_src sh :dir .. :results output :exports results :post crop(text=*this*, first-n=9, last-n=0)
nix --experimental-features nix-command search --file . . | ansifilter
#+end_src

#+RESULTS: nix-search-local
#+begin_example
,* default

,* packages.aarch64-darwin.nix-scaffold
  Script to scaffold a Nix project

,* packages.aarch64-darwin.org2gfm
  Script to export Org-mode files to GitHub Flavored Markdown (GFM)

,* packages.x86_64-darwin.nix-scaffold
…
#+end_example

Passing in ~--file .~ tells =nix search= to read a Nix expression from a file.
The next positional argument when calling with =--file= is the attribute path to
start the search from. An empty string indicates to start at the root of the
attribute tree found in the expression read.

Note, there are some projects for which =nix search= won't work. These projects
rely on an advanced technique called /import from derivation (IFD)/. =nix
search= will fail on these projects with a message indicating this features is
disabled, even if it's not.

For these projects, you can still navigate its attribute tree with =nix repl=.
Or you can try to read the source code of the Nix expressions.

** Inspecting other projects for packages

Flakes give us a convenient way to reference both local and remote projects.
Without flakes, we have to download the upstream Nix expressions for remote
projects. We'll then have Nix expressions we can import into our own.

If these projects provide a =default.nix= expression, you can use the same
commands introduced in the prior exception, with on important exception of
[[nixpkgs][Nixpkgs]], the main repository providing packages for the Nix ecosystem.

Nixpkgs has so many packages, you can't search it easily without flakes enabled.
You can, though, tab-complete through it with =nix repl=. As an alternative,
consider using [[nixos-search][NixOS's online search engine]].

Note, this document intentionally doesn't cover either the =nix-channel= command
or the =NIX_PATH= environment variable. Using either of these legacy features of
Nix leads systems to unnecessary unreliability, compromising the reasons to
advocate for Nix in the first place. If you really want to track and access
remote repositories, access them with an explicit checkout of a pinned
version/commit.

** Building installables

The following result is one returned by our prior execution of =nix search= or
tab-completing with =nix repl=:

#+name: nix-search-specific
#+begin_src sh :dir .. :results output :exports results :noweb yes
nix search --file . '' packages.x86_64-linux.'<<get("package-attr")>>' --json | jq . | ansifilter
#+end_src

#+RESULTS: nix-search-specific
: {
:   "packages.x86_64-linux.nix-scaffold": {
:     "pname": "nix-scaffold",
:     "version": "",
:     "description": "Script to scaffold a Nix project"
:   }
: }

We can see that a package can be accessed with the {{{package-attr-long}}}
output attribute path of the project's flake. Not shown in the search results
above, this package happens to provide the {{{package-type}}}
{{{package-target}}}.

We can build this package with =nix-build= from the project root:

#+name: nix-build
#+begin_src sh :dir .. :results output :exports both :noweb yes
nix-build --attr packages.x86_64-linux.<<get("package-attr")>> .
#+end_src

#+RESULTS: nix-build
: /nix/store/gydpxb0v52gcw2md0pxfyash56jzvrdg-nix-scaffold

If we omit the path to a Nix file, =nix-build= will try to build =default.nix=
in the current directory. If we don't omit the =--attr= switch and argument,
=nix-build= will try to build packages it finds in the root of the attribute
tree.

All packages built by Nix are stored in =/nix/store=. Nix won't rebuild packages
found there. Once a package is built, its content in =/nix/store= is read-only
(until the package is garbage collected, discussed later).

The output of =nix-build= shows us where in =/nix/store= our package has been
built. Additionally, as a convenience, =nix-build= creates one or more symlinks
for each package requested in the current working directory. These symlinks by
default have a name prefixed with "result" and point back to the respective
build in =/nix/store=:

#+name: nix-build-link
#+begin_src sh :dir .. :results output :exports both
readlink result*
#+end_src

#+RESULTS: nix-build-link
: /nix/store/yzkbxisa1clj22210bbasbv3ji3h83p0-nix-scaffold

Following these symlinks, we can see the files the project provides:

#+name: nix-build-tree
#+begin_src sh :dir .. :results output :exports both :post crop(text=*this*, first-n=10, last-n=0)
tree -l result*
#+end_src

#+RESULTS: nix-build-tree
: result
: └── bin
:     └── nix-scaffold
:
: 1 directory, 1 file

It's common to configure these "result" symlinks as ignored in source control
tools (for instance, for Git within a =.gitignore= file).

=nix build= has a =--no-out-link= switch in case you want to build packages
without creating "result" symlinks.

** Running commands in a shell

We can run commands in Nix-curated environments with =nix shell=, provided we're
okay enabling the =nix-command= experimental feature. Nix will take executables
found in packages, put them in an environment's =PATH=, and then execute a
user-specified command.

With =nix shell=, you don't even have to build the package first with =nix
build= or mess around with "result" symlinks. =nix shell= will build any
necessary packages required.

For example, to get the help message for the {{{run-target}}} executable
provided by the package selected by the {{{run-attr}}} attribute path output by
this project's flake, we can call the following:

#+name: nix-shell
#+begin_src sh :dir .. :results output :exports both :noweb yes :post crop(text=*this*, first-n=5, last-n=0)
nix shell \
    --file . \
    packages.x86_64-linux.<<get("run-attr")>> \
    --command <<get("run-target")>> --help
#+end_src

#+RESULTS: nix-shell
: USAGE: nix-scaffold [OPTION]...
:
: DESCRIPTION:
:
:     Scaffolds a new project based on Nix flakes.
: …

=nix shell= is normally used with flake projects, but when we call it with the
=--file= switch, we can specify a Nix file for the project.  This puts
=nix shell= in a different mode where positional arguments are interpreted
as attribute paths to use to select out packages from the attribute tree evaluated

Similar to other =nix= subcommands, passing in ~--file .~ tells =nix shell= to
read a Nix expression from a file. The positional arguments when calling with
=--file= are the attribute paths selecting packages to put on the =PATH=.

The command to run is specified after the =--command= switch. =nix shell= runs
the command in a shell set up with a =PATH= environment variable including all
the =bin= directories provided by the selected packages.

If you just want to drop into a shell with the set up =PATH=, you can drop the
=--command== switch and following arguments.

=nix shell= also supports an =--ignore-environment= flag that restricts =PATH=
to only packages selected, rather than extending the =PATH= of the caller's
environment. With =--ignore-environment=, the invocation is more sandboxed.

** Installing and uninstalling programs

We've seen that we can build programs with =nix-build= and then execute them
using the "result" symlink (=result/bin/*=). Additionally, we've seen that you
can run programs with =nix shell=. But these additional steps and
switches/arguments can feel extraneous. It would be nice if we could just have
the programs on our =PATH=. This is what =nix-env= is for.

=nix-env= maintains a symlink tree, called a /profile/, of installed programs.
The active profile is pointed to by a symlink at =~/.nix-profile=. By default,
this profile points to =/nix/var/nix/profiles/per-user/$USER/profile=. But you
can point your =~/.nix-profile= to any writable location with the
=--switch-profile= switch:

#+begin_src sh :eval no
nix-env --switch-profile /nix/var/nix/profiles/per-user/$USER/another-profile
#+end_src

This way, you can just put =~/.nix-profile/bin= on your =PATH=, and any programs
installed in your currently active profile will be available for interactive use
or scripts.

To install the {{{package-target}}} {{{package-type}}}, which is provided by the
{{{package-attr-long}}} attribute path, we'd run the following:

#+name: nix-env-install
#+begin_src sh :session env :results output :exports both :noweb yes :post crop(text=*this*, first-n=1, last-n=3)
nix-env --install --file . --attr packages.x86_64-linux.<<get("package-attr")>> 2>&1
#+end_src

#+RESULTS: nix-env-install
: warning: Git tree '/home/tnks/src/shajra/nix-project' is dirty
: installing 'nix-scaffold'
: building '/nix/store/fl97r7b9qdgcba259lx12znq80njb6v5-user-environment.drv'...

We can see this installation by querying what's been installed:

#+name: nix-env-query-2
#+begin_src sh :session env :results output :exports both
nix-env --query
#+end_src

#+results: nix-env-query-2
: nix-scaffold

Note that this name we see in the results of =nix-env= is not always going to be
congruent with the attribute path we used to select out our packages.

If we're fortunate to not have a package that uses IFDs, we can see more meta
information with nix3-search:

#+name: nix-search-2
#+begin_src sh :dir .. :results output :exports both :noweb yes
nix search --file . '' '<<get("package-attr")>>' | ansifilter
#+end_src

#+RESULTS: nix-search-2
: * packages.aarch64-darwin.nix-scaffold
:   Script to scaffold a Nix project
:
: * packages.x86_64-darwin.nix-scaffold
:   Script to scaffold a Nix project
:
: * packages.x86_64-linux.nix-scaffold
:   Script to scaffold a Nix project

And if we want to uninstall a program from our active profile, we do so by the
package's name, in this case {{{package-name}}}:

#+name: nix-env-uninstall
#+begin_src sh :session env :results output :exports both :noweb yes
nix-env --uninstall <<get("package-name")>> 2>&1
#+end_src

#+RESULTS: nix-env-uninstall
: uninstalling 'nix-scaffold'

Note that we've installed our package using its attribute path
({{{package-attr}}}) within the referenced Nix expression. But we uninstall it
using the package name ({{{package-name}}}), which may or may not be the same as
the attribute path. When a package is installed, Nix keeps no reference to the
expression that evaluated to the derivation of the installed package. The
attribute path is only relevant to this expression. In fact, two different
expressions could evaluate to the same derivation, but use different attribute
paths. This is why we uninstall packages by their package name.

Also, if you look at the location for your profile, you'll see that Nix retains
the symlink trees of previous generations of your profile. In fact you can even
rollback to a previous profile with the =--rollback= switch. You can delete old
generations of your profile with the =--delete-generations= switch.

** Garbage collection

Every time you build a new version of your code, it's stored in =/nix/store=.
You can call =nix store gc= to purge unneeded packages. Programs that should not
be removed by =nix store gc= that can be found by starting with symlinks stored
as /garbage collection (GC) roots/ under three locations:

  - =/nix/var/nix/gcroots=
  - =/nix/var/nix/profiles=
  - =/nix/var/nix/manifests=.

For each package, Nix is aware of all references back to other packages in
=/nix/store=, whether in text files or binaries. This helps Nix assure that
dependencies of packages linked as GC roots won't be deleted.

Each "result" symlink created by a =nix build= invocation has a symlink in
=/nix/var/nix/gcroots/auto= pointing back it. So we've got symlinks in
=/nix/var/nix/gcroots/auto= pointing to "result" symlinks in our projects, which
then reference the actual built project in =/nix/store=. These chains of
symlinks prevent packages built by =nix build= from being garbage collected.

If you want a package you've built with =nix build= to be garbage collected,
delete the "result" symlink created before calling =nix store gc=. Breaking
symlink chains under =/nix/var/nix/gcroots= removes protection from garbage
collection. =nix store gc= will clean up broken symlinks when it runs.

Note that everything under =/nix/var/nix/profiles= is considered a GC root as
well. This is why users by convention use this location to store their Nix
profiles.

Also, note if you delete a “result*” link and call =nix store gc=, though some
garbage may be reclaimed, you may find that an old profile is keeping the
program alive. Use the =nix profile wipe-history= command to delete old profiles
before calling =nix store gc=.

It's also good to know that =nix store gc= won't delete packages referenced by
any running processes. In the case of =nix run= no garbage collection root
symlink is created under =/nix/var/nix/gcroots=, but while =nix run= is running
=nix store gc= won't delete packages needed by the running command. However,
once the =nix run= call exits, any packages pulled from a substitutor or built
locally are candidates for deletion by =nix store gc=. If you called =nix run=
again after garbage collecting, those packages may be pulled or built again.

* Next steps

This document has covered a fraction of Nix usage, hopefully enough to introduce
Nix in the context of [[file:../README.org][this project]].

An obvious place to start learning more about Nix is [[nix-learn][the official documentation]].
The author of this project also maintains another project with [[nix-tutorial][a small tutorial
on Nix]]. This tutorial covers the Nix expression language in more detail.

All the commands we've covered have more switches and options. See the
respective man pages for more. Also, we didn't cover =nix-shell=, which can be
used for setting up development environments. And we didn't cover much of
[[nixpkgs][Nixpkgs]], the gigantic repository of community-curated Nix expressions.

The Nix ecosystem is vast. This project and documentation illustrates just a
small sample of what Nix can do.

* Org-mode teardown :noexport:

#+call: cleanup()
